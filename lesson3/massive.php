<?php

// массив в старом синтаксисе до php 5.3 включительно
$a = array(1, 2, 3);

// массив в новом синтаксисе от php 5.4
$a = [1, 2, 3];

// ключи массива нигде не задавали, поэтому элементы нумеруются числами, с нуля
echo $a[0]; // 1
echo $a[1]; // 2

// нигде не вводили длину массива - массивы имеют динамическую длину
var_dump($a); // array(3) { [0]=> int(1) [1]=> int(2) [2]=> int(3) }

// добавить элемент в массив - для всех версий php
$a[] = 4; // получит первый свободный числовой индекс
var_dump($a); // array(4) { [0]=> int(1) [1]=> int(2) [2]=> int(3) [3]=> int(4) }

// как задать самим индекс
$a[10] = 4; // элементу массива с индексом 10 присвоить значение 4
// в массиве 5 элементов, один из них с индексом 10
var_dump($a); // array(5) { [0]=> int(1) [1]=> int(2) [2]=> int(3) [3]=> int(4) [10]=> int(4) }

// обратиться к элементу массива по индексу
$a[5] = 10;
$a[5] = 5;
var_dump($a);  // array(6) { [0]=> int(1) [1]=> int(2) [2]=> int(3) [3]=> int(4) [10]=> int(4) [5]=> int(5) }
// номера индексов не идут подряд

// удаление элементов массива - оператор unset(...)
unset($a[5]);
var_dump($a); // array(5) { [0]=> int(1) [1]=> int(2) [2]=> int(3) [3]=> int(4) [10]=> int(4) }

// индекс - это не порядковый номер в массиве, это просто некая метка, которую мы задаём элементу,
// чтобы быстро его по этой метке найти


// в php нет ограничений на тип входящих в массив значений
// внутри массива могут блыть даже массивы
$a = [1, 'foo', true];
var_dump($a); // array(3) { [0]=> int(1) [1]=> string(3) "foo" [2]=> bool(true) }

// задать элементы массива и задать значения ключей для них с помощью =>
$a = [
    10 => 1,
    20 => 'foo',
    30 => true, // после последнего элемента массива можно оставлять запятую
];
var_dump($a); // array(3) { [10]=> int(1) [20]=> string(3) "foo" [30]=> bool(true) }

// массив через echo не выводится
echo $a; //  Array
// если выводить через echo то только так:
echo $a[10] . $a[20] . $a[30]; // 1foo1

// индексы массивов не обязательно числовые - могут быть, например, строки
$a = [
    '10' => 1,
    '20' => 'foo',
    '30' => true, // после последнего элемента массива можно оставлять запятую
];
var_dump($a); // array(3) { [10]=> int(1) [20]=> string(3) "foo" [30]=> bool(true) }

$a = [
    'foo' => 1,
    'bar' => 'foo',
    'baz' => true, // после последнего элемента массива можно оставлять запятую
];
var_dump($a); // array(3) { ["foo"]=> int(1) ["bar"]=> string(3) "foo" ["baz"]=> bool(true) }

// обращение к элементу массива со строковым индексом
echo $a['foo']; // 1

// пример использования строкового индекса массива: в один массив можем запихнуть всю информацию о пользователе
// является ли он активным пользователем и т.д.
$user['birthday'] = '2005-05-05';

// массив это хеш, таблица соответствия между индексами и значениями

/*
 * - Элементом массива может быть функция?
 * - Может. В php есть анонимные функции.
 *      Функция может быть переменной,
 *      может быть элементом массива,
 *      есть возможность из функции в качестве результатат вернуть другую функцию
 *
 * */

// многомерные массивы
// в php допускается неограниченная вложенность массивов друг в друга

// задание многомерного массива
$aLanguages = [
    "Slavic" => ["Russian", "Polish", "Slovenian"],
    "Germanic" => ["Swedish", "Dutch", "English"],
    "Roman" => ["Italian", "Spanish", "French"],
];

// доступ к элементам многомерного массива
echo $aLanguages["Germanic"][2]; // English